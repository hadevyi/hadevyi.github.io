---
title: "[Beakjoon] 1193번 분수찾기"
categories:
  - Beakjoon
tags:
  - algorithm
  - beakjoon
toc: true
toc_sticky: true
toc_label: "1193번 분수찾기"
toc_icon: "sticky-note"
---

📣<br>
**Beakjoon**에서 PASS된 코드만 업데이트합니다.<br>
알고리즘을 먼저 풀이하는 언어(Java)가 정해져있어, 
풀이 언어(Python, C++, Java)가 모두 업데이트될 때까지는 시간이 걸릴 수 있습니다.
{: .notice--primary}

# 문제 제시

---

<br>
<b><u><span style="font-size:20px">문제</span></u></b>

무한히 큰 배열에 다음과 같이 분수들이 적혀있다.<br>

1/1		1/2		1/3		1/4		1/5		…
2/1		2/2		2/3		2/4		…			…
3/1		3/2		3/3		…			…			…
4/1		4/2		…			…			…			…
5/1		…			…			…			…			…
…		  …			…			…			…			…

이와 같이 나열된 분수들을 1/1 -> 1/2 -> 2/1 -> 3/1 -> 2/2 -> … 과 같은 지그재그 순서로 차례대로 1번, 2번, 3번, 4번, 5번, … 분수라고 하자.<br>
X가 주어졌을 때, X번째 분수를 구하는 프로그램을 작성하시오.<br>

<br>
<b><u><span style="font-size:20px">입력</span></u></b>

첫째 줄에 X(1 ≤ X ≤ 10,000,000)가 주어진다.

<br>
<b><u><span style="font-size:20px">출력</span></u></b>

첫째 줄에 분수를 출력한다.

<br>
<br>

# 문제 풀이

---

![image](https://user-images.githubusercontent.com/45550607/108089230-b5ba9a80-70bc-11eb-8eed-c0d7efab41a9.png){: .image-center}

분자와 분모가 각 행과 열의 특징을 그대로 나타내고 있습니다.<br>
따라서 모든 배열의 내용을 할당하고 탐색하는 것이 아닌 i,j의 특징을 찾아서 바로 표현하면 됩니다.<br>
또한 전체적으로 순서대로 진행되면서, 증가/감소 여부만 다르고 동일한 제한 조건(인덱스가 1 이상)을 가집니다.<br>
이를 스위치 변수로 삼아 구현하면 됩니다.<br>
<br>
스위치 변수를 T/F로 하는 것이 아닌 1/-1로 하면 이를 바로 연산하면 됩니다.<br>
즉, 증가할 때와 감소할 때의 코드를 별개로 짤 필요가 없는 것이죠.<br>

<br>
<br>

# 문제 코드

## Java

<script src="https://gist.github.com/eona1301/b6242396be3fadf0470479bb05d943c2.js"></script>

<br>
<br>

# 제출 결과

![image](https://user-images.githubusercontent.com/45550607/108090746-4fcf1280-70be-11eb-8745-f30fbafc9c12.png){: .image-center}

